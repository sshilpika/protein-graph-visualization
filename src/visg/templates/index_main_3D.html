
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="#">
  <link rel="stylesheet" href="/static/css/main_style.css">
  <title>Graph Visualization</title>

  <script type="text/javascript" src="/static/js/sijax/sijax.js"></script>
  <script type="text/javascript">{{ g.sijax.get_js()|safe }} </script>
  <script src="{{ url_for('static',filename='js/jqueryv3.5.1.js')}}"></script>

  <script src="{{ url_for('static', filename='js/d3.v7.js')}}"></script>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/dat.gui"></script>
  <script src="//unpkg.com/d3-octree"></script>
  <script src="//unpkg.com/d3-force-3d"></script>
  <script src="//unpkg.com/3d-force-graph"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@v0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@v0.158.0/examples/jsm/"
      }
    }
  </script>
  <script type="text/javascript" src="/static/js/my_utils.js"></script>
</head>
<body>

<div id="3d-graph"></div>

<script>

  const elem = document.getElementById('3d-graph');
  let isAnimationActive = true;
  const initData = {
    nodes: [],
    links: []
  };
  const color8 = "#F3A9"; // for redefining color shades
  let counter = 0;
  const highlightNodes = new Set();
  const highlightLinks = new Set();
  let hoverNode = null;
  let showLinkParticle = false;
  let showNeighbors = false;
  let enableNodeDragging = false;
  let enablePointerInteractions = true;
  let pauseAnimation = false;
  let showLinkWidth = false;
  let counterStopAt = 10;

  const Graph = ForceGraph3D()(elem)
          .backgroundColor('#00000f') //#101020
          .graphData(initData)
          .enableNodeDrag(enableNodeDragging)
          .enablePointerInteraction(enablePointerInteractions)
          .nodeId('id')
          .nodeLabel(node => {
            return showNeighbors ? `${node.id} â†’ ${node.neighbors}`: `${node.id}`;
          })
          .nodeColor(node => {
            return highlightNodes.has(node.id) ? node.id === hoverNode ? 'red' : 'rgba(255,160,0,0.8)' : "gray";
          })
          .nodeVal(node => (node.neighbors.length > 20 && node.neighbors.length < 30) ? 2 : (node.neighbors.length >= 30) ? 3 : 1)
          .nodeResolution(20)
          .linkColor(link => link.color ? link.color : 'gray' )
          .linkOpacity(0.5)
          .linkDirectionalParticles(link => {
            if(showLinkParticle)
              return 4;
            else
              return [...highlightLinks].filter((x) => x.source.id===link.source.id && x.target.id===link.target.id).length !== 0 ? 4 : 0;
          })
          .linkDirectionalParticleWidth(2)
          // .linkWidth(link => (showLinkWidth && link.penwidth) ? link.penwidth : 0 )
          .linkWidth(link => [...highlightLinks].filter((x) => x.source.id===link.source.id && x.target.id===link.target.id).length!==0 ? 4 : link.penwidth ? link.penwidth : 0 )
          .linkDirectionalArrowLength(2)
          .linkDirectionalArrowRelPos(1)
          .linkDirectionalArrowColor(link => link.color ? pSBC ( 0.1, standardize_color(link.color), color8 ) : 'gray' )
          .linkCurvature(0.2)
          .onNodeClick(node => {

            // no state change
            if (!node && !highlightNodes.size) return;

            if (node && !highlightNodes.has(node.id)) {

              highlightNodes.add(node.id);
              node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
              node.links.forEach(link => highlightLinks.add(link));
            }else{
              highlightNodes.clear();
              highlightLinks.clear();
              hoverNode = null;
              updateHighlight();
              return;
            }

            hoverNode = !node ? null : node.id || null;

            updateHighlight();
          })
          .onLinkClick(link => {

            if(highlightNodes.has(link.source.id) && highlightNodes.has(link.target.id)){
              highlightNodes.clear();
              highlightLinks.clear();
              updateHighlight();
              return;
            }

            highlightNodes.clear();
            highlightLinks.clear();

            if (link && !highlightNodes.has(link.source.id) && !highlightNodes.has(link.target.id)) {
              highlightLinks.add(link);
              highlightNodes.add(link.source.id);
              highlightNodes.add(link.target.id);
            }

            updateHighlight();
          });

  // light the 3D scene
  Graph.lights()[0].intensity = 500.0;
  Graph.lights()[1].intensity = 15.0;

  // force directed d3 simulation set up
  Graph.d3Force('collide', d3.forceCollide(collisonStrengthVal))
          .d3AlphaDecay(0.02)
          .d3VelocityDecay(0.3)
          .d3Force("charge", d3.forceManyBody().strength(-200))
          .d3Force('link');

  // trigger update of highlighted objects in scene
  function updateHighlight() {

    Graph
            .nodeColor(Graph.nodeColor())
            //.linkWidth(Graph.linkWidth())
            .linkDirectionalParticles(Graph.linkDirectionalParticles());
  };



  // module for timed calls for graph updates

  const reloadGraphData = ( reset = false, stopAt = counterStopAt ) => {

    counter = 0;
    console.log("stop at", +stopAt, counter, counterStopAt)
    counterStopAt = +stopAt;
    const myInterval = setInterval(() => {
      if(!pauseAnimation && counter < counterStopAt){
        console.log("counter", counter, counterStopAt)
        dataUpdateCallback(reset);
        if(reset) reset = false;
        counter+=1;

        if(counter % 2 === 0)
          zoomToFit();

      }

      //if(counter >= counterStopAt)
      Sijax.request("checkStopAt", [counterStopAt])
    }, 12000);

    function stopFunction() {
      clearInterval(myInterval);
    }

    return {
      stopFunction: stopFunction,
      myInterval: myInterval

    };

  }

  // stop the timer at counterStopAt - which is updated as the data comes in
  function updateStopAt(newCounterStop) {

    counterStopAt = (counterStopAt !== +newCounterStop) ? newCounterStop: counterStopAt;
  }

  // callback for processing data partitions
  function dataUpdateCallback(reset){
    Sijax.request('getDataPartions', [counter.toString(), reset.toString()]);

  }

  // main graph load and backend data update listener
  reloadGraphData();
  Sijax.request("watchMasterFile")

  // update graph with new data
  function addGraphData(dataPart, reset = false){

    if(reset){
      console.log("resetting...")
      Graph.graphData(initData)
    }

    const { nodes, links } = Graph.graphData();

    let newNodes = [];
    let oldNodes = [];
    let nodesFound = [];
    if(nodes.length !== 0){
      nodes.forEach(n => {
        const oldNVals = [...dataPart.nodes].filter(newN => (newN.id === n.id))[0]

        if(!oldNVals || oldNVals.length === 0){
          oldNodes.push(n)
        } else{
          nodesFound.push(n.id);
          const oldLinkVals = [...dataPart.links].filter(newL => (newL.source === n.id) || (newL.target === n.id))

          n.links = [...n.links, ...oldLinkVals]
          n.neighbors = [...new Set([...n.neighbors, ...oldNVals.neighbors])]
          oldNodes.push(n)
        }


      })
      newNodes = dataPart.nodes.filter(newN => !(nodesFound.includes(newN.id)))
    }else{
      newNodes = dataPart.nodes
    }

    Graph.graphData({
      nodes: [...oldNodes, ...newNodes ],
      links: [...links, ...dataPart.links ]
    });

    zoomToFit();

  }



  //Define GUI and functions
  const Settings = function() {
    this.redDistance = 10000;
    this.MinLinks = 0;
    this.MaxLinks = 3000000;
    this.NodeDistance = collisonStrengthVal;
  };


  // Toggle Link Particles
  const toggleLinkAnimation = () => {
    if(!showLinkParticle){
      highlightNodes.clear();
      hoverNode = null;
      highlightLinks.clear();
      updateHighlight();
    }
    else{
      Graph
          .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }
    showLinkParticle = !showLinkParticle;

  }

  //Zoom to Fit
  const zoomToFit = () => {
    Graph.zoomToFit(0,10,node=> true)

  }

  // show node neighbors or not on node hover
  const showNodeNeighbors = () => {
    showNeighbors = !showNeighbors;
    Graph
        .nodeLabel(Graph.nodeLabel());
  }

  // enable node rearrange - this is disabled for large graphs
  const enableNodeRearrange = () => {
    enableNodeDragging = !enableNodeDragging;
    Graph
            .enableNodeDrag(Graph.enableNodeDrag());

  }

  // pause or resume data partitions load from backend
  const pauseResumeDataLoad = () => {
    pauseAnimation = !pauseAnimation;
  }

  // update the node distance - disabled for large disconnected graph
  function collisionUpdate(){
    console.log("collisionUpdate now...")
    Graph.d3Force('collide', d3.forceCollide(settings.collisionStrength))
            .d3AlphaDecay(0.02)
            .d3VelocityDecay(0.3);
    Graph.numDimensions(3);
  }


  // showLinkWidth
  const toggleLinkWidth = () => {
    showLinkWidth = !showLinkWidth;
    Graph
        .linkWidth(Graph.linkWidth())
  }

  // update graph when max and min links connecting the graph is specified
  function updateLinkCount(minLinks = settings.MinLinks, maxLinks = settings.MaxLinks) {
    reloadGraphData().stopFunction()
    console.log("Setting min and max node links!", minLinks, maxLinks )
    // pauseAnimation = true;
    Sijax.request("setNodeLinkLimit", [minLinks, maxLinks])

  }


  // set up vis for GUI
  const settings = new Settings();
  const gui = new dat.GUI();

  var folder2 = gui.addFolder('Sparse Layout Settings');
  const controllerTwo = folder2.add(settings, 'MinLinks', 0, 20000);
  const controllerThree = folder2.add(settings, 'MaxLinks', 0, 4000000);
  folder2.add({ 'Enter': updateLinkCount }, 'Enter');
  folder2.open();

  var folder3 = gui.addFolder('GUI Buttons');
  folder3.add({ 'Zoom to Fit': zoomToFit }, 'Zoom to Fit');
  folder3.add({ 'Show Link Directions': toggleLinkAnimation }, 'Show Link Directions');
  // folder3.add({ 'Show Link Width': toggleLinkWidth }, 'Show Link Width');
  folder3.add({ 'Show Node Neighbors': showNodeNeighbors }, 'Show Node Neighbors');
  folder3.add({ 'Pause/Resume Data Reload': pauseResumeDataLoad }, 'Pause/Resume Data Reload');
  folder3.open();




</script>

</body>
